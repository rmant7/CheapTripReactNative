{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var InteractionManager=function(){function InteractionManager(){_classCallCheck(this,InteractionManager);_defineProperty(this,\"waitForRelations\",new Map());_defineProperty(this,\"simultaneousRelations\",new Map());}_createClass(InteractionManager,[{key:\"configureInteractions\",value:function configureInteractions(handler,config){this.dropRelationsForHandlerWithTag(handler.getTag());if(config.waitFor){var waitFor=[];config.waitFor.forEach(function(otherHandler){if(typeof otherHandler==='number'){waitFor.push(otherHandler);}else{waitFor.push(otherHandler.handlerTag);}});this.waitForRelations.set(handler.getTag(),waitFor);}if(config.simultaneousHandlers){var simultaneousHandlers=[];config.simultaneousHandlers.forEach(function(otherHandler){if(typeof otherHandler==='number'){simultaneousHandlers.push(otherHandler);}else{simultaneousHandlers.push(otherHandler.handlerTag);}});this.simultaneousRelations.set(handler.getTag(),simultaneousHandlers);}}},{key:\"shouldWaitForHandlerFailure\",value:function shouldWaitForHandlerFailure(handler,otherHandler){var waitFor=this.waitForRelations.get(handler.getTag());if(!waitFor){return false;}var shouldWait=false;waitFor.forEach(function(tag){if(tag===otherHandler.getTag()){shouldWait=true;return;}});return shouldWait;}},{key:\"shouldRecognizeSimultaneously\",value:function shouldRecognizeSimultaneously(handler,otherHandler){var simultaneousHandlers=this.simultaneousRelations.get(handler.getTag());if(!simultaneousHandlers){return false;}var shouldRecognizeSimultaneously=false;simultaneousHandlers.forEach(function(tag){if(tag===otherHandler.getTag()){shouldRecognizeSimultaneously=true;return;}});return shouldRecognizeSimultaneously;}},{key:\"shouldRequireHandlerToWaitForFailure\",value:function shouldRequireHandlerToWaitForFailure(_handler,_otherHandler){return false;}},{key:\"shouldHandlerBeCancelledBy\",value:function shouldHandlerBeCancelledBy(_handler,_otherHandler){return false;}},{key:\"dropRelationsForHandlerWithTag\",value:function dropRelationsForHandlerWithTag(handlerTag){this.waitForRelations.delete(handlerTag);this.simultaneousRelations.delete(handlerTag);}},{key:\"reset\",value:function reset(){this.waitForRelations.clear();this.simultaneousRelations.clear();}}],[{key:\"getInstance\",value:function getInstance(){if(!this.instance){this.instance=new InteractionManager();}return this.instance;}}]);return InteractionManager;}();export{InteractionManager as default};_defineProperty(InteractionManager,\"instance\",void 0);","map":{"version":3,"mappings":"yTAGqBA,mBAAN,YAOLC,6BAAc,kFALqC,GAAIC,IAAJ,EAKrC,+CAJ0C,GAAIA,IAAJ,EAI1C,EAAE,qEAEjBC,+BAAsBC,OAAD,CAA0BC,MAA1B,CAA0C,CACpE,KAAKC,8BAAL,CAAoCF,OAAO,CAACG,MAAR,EAApC,EAEA,GAAIF,MAAM,CAACG,OAAX,CAAoB,CAClB,GAAMA,QAAiB,CAAG,EAA1B,CACAH,MAAM,CAACG,OAAP,CAAeC,OAAf,CAAwBC,qBAAD,CAAiC,CAEtD,GAAI,MAAOA,aAAP,GAAwB,QAA5B,CAAsC,CACpCF,OAAO,CAACG,IAAR,CAAaD,YAAb,EACD,CAFD,IAEO,CAELF,OAAO,CAACG,IAAR,CAAaD,YAAY,CAACE,UAA1B,EACD,CACF,CARD,EAUA,KAAKC,gBAAL,CAAsBC,GAAtB,CAA0BV,OAAO,CAACG,MAAR,EAA1B,CAA4CC,OAA5C,EACD,CAED,GAAIH,MAAM,CAACU,oBAAX,CAAiC,CAC/B,GAAMA,qBAA8B,CAAG,EAAvC,CACAV,MAAM,CAACU,oBAAP,CAA4BN,OAA5B,CAAqCC,qBAAD,CAAiC,CACnE,GAAI,MAAOA,aAAP,GAAwB,QAA5B,CAAsC,CACpCK,oBAAoB,CAACJ,IAArB,CAA0BD,YAA1B,EACD,CAFD,IAEO,CACLK,oBAAoB,CAACJ,IAArB,CAA0BD,YAAY,CAACE,UAAvC,EACD,CACF,CAND,EAQA,KAAKI,qBAAL,CAA2BF,GAA3B,CAA+BV,OAAO,CAACG,MAAR,EAA/B,CAAiDQ,oBAAjD,EACD,CACF,4CAEME,qCACLb,OADgC,CAEhCM,YAFgC,CAGvB,CACT,GAAMF,QAA6B,CAAG,KAAKK,gBAAL,CAAsBK,GAAtB,CACpCd,OAAO,CAACG,MAAR,EADoC,CAAtC,CAGA,GAAI,CAACC,OAAL,CAAc,CACZ,MAAO,MAAP,CACD,CAED,GAAIW,WAAU,CAAG,KAAjB,CAEAX,OAAO,CAACC,OAAR,CAAiBW,YAAD,CAAuB,CACrC,GAAIA,GAAG,GAAKV,YAAY,CAACH,MAAb,EAAZ,CAAmC,CACjCY,UAAU,CAAG,IAAb,CACA,OACD,CACF,CALD,EAOA,MAAOA,WAAP,CACD,8CAEME,uCACLjB,OADkC,CAElCM,YAFkC,CAGzB,CACT,GAAMK,qBAA0C,CAC9C,KAAKC,qBAAL,CAA2BE,GAA3B,CAA+Bd,OAAO,CAACG,MAAR,EAA/B,CADF,CAEA,GAAI,CAACQ,oBAAL,CAA2B,CACzB,MAAO,MAAP,CACD,CAED,GAAIM,8BAA6B,CAAG,KAApC,CAEAN,oBAAoB,CAACN,OAArB,CAA8BW,YAAD,CAAuB,CAClD,GAAIA,GAAG,GAAKV,YAAY,CAACH,MAAb,EAAZ,CAAmC,CACjCc,6BAA6B,CAAG,IAAhC,CACA,OACD,CACF,CALD,EAOA,MAAOA,8BAAP,CACD,qDAEMC,8CACLC,QADyC,CAEzCC,aAFyC,CAGhC,CAET,MAAO,MAAP,CACD,2CAEMC,oCACLF,QAD+B,CAE/BC,aAF+B,CAGtB,CAET,MAAO,MAAP,CACD,+CAEMlB,wCAA+BM,UAAD,CAA2B,CAC9D,KAAKC,gBAAL,CAAsBa,MAAtB,CAA6Bd,UAA7B,EACA,KAAKI,qBAAL,CAA2BU,MAA3B,CAAkCd,UAAlC,EACD,sBAEMe,gBAAQ,CACb,KAAKd,gBAAL,CAAsBe,KAAtB,GACA,KAAKZ,qBAAL,CAA2BY,KAA3B,GACD,8BAEwB,sBAAuB,CAC9C,GAAI,CAAC,KAAKC,QAAV,CAAoB,CAClB,KAAKA,QAAL,CAAgB,GAAI7B,mBAAJ,EAAhB,CACD,CAED,MAAO,MAAK6B,QAAZ,CACD,0CAtHkB7B,kBAAN,6BAAMA,kB","names":["InteractionManager","constructor","Map","configureInteractions","handler","config","dropRelationsForHandlerWithTag","getTag","waitFor","forEach","otherHandler","push","handlerTag","waitForRelations","set","simultaneousHandlers","simultaneousRelations","shouldWaitForHandlerFailure","get","shouldWait","tag","shouldRecognizeSimultaneously","shouldRequireHandlerToWaitForFailure","_handler","_otherHandler","shouldHandlerBeCancelledBy","delete","reset","clear","instance"],"sources":["InteractionManager.ts"],"sourcesContent":["import GestureHandler from '../handlers/GestureHandler';\nimport { Config, Handler } from '../interfaces';\n\nexport default class InteractionManager {\n  private static instance: InteractionManager;\n  private readonly waitForRelations: Map<number, number[]> = new Map();\n  private readonly simultaneousRelations: Map<number, number[]> = new Map();\n\n  // Private becaues of singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  public configureInteractions(handler: GestureHandler, config: Config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n\n    if (config.waitFor) {\n      const waitFor: number[] = [];\n      config.waitFor.forEach((otherHandler: Handler): void => {\n        // New API reference\n        if (typeof otherHandler === 'number') {\n          waitFor.push(otherHandler);\n        } else {\n          // Old API reference\n          waitFor.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers: number[] = [];\n      config.simultaneousHandlers.forEach((otherHandler: Handler): void => {\n        if (typeof otherHandler === 'number') {\n          simultaneousHandlers.push(otherHandler);\n        } else {\n          simultaneousHandlers.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n  }\n\n  public shouldWaitForHandlerFailure(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const waitFor: number[] | undefined = this.waitForRelations.get(\n      handler.getTag()\n    );\n    if (!waitFor) {\n      return false;\n    }\n\n    let shouldWait = false;\n\n    waitFor.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldWait = true;\n        return; //Returns from callback\n      }\n    });\n\n    return shouldWait;\n  }\n\n  public shouldRecognizeSimultaneously(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const simultaneousHandlers: number[] | undefined =\n      this.simultaneousRelations.get(handler.getTag());\n    if (!simultaneousHandlers) {\n      return false;\n    }\n\n    let shouldRecognizeSimultaneously = false;\n\n    simultaneousHandlers.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldRecognizeSimultaneously = true;\n        return;\n      }\n    });\n\n    return shouldRecognizeSimultaneously;\n  }\n\n  public shouldRequireHandlerToWaitForFailure(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public shouldHandlerBeCancelledBy(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public dropRelationsForHandlerWithTag(handlerTag: number): void {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n  }\n\n  public reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n  }\n\n  public static getInstance(): InteractionManager {\n    if (!this.instance) {\n      this.instance = new InteractionManager();\n    }\n\n    return this.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}