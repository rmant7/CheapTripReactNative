{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{EventTypes,MouseButtons,PointerType,TouchEventType}from\"../interfaces\";import EventManager from\"./EventManager\";import{isPointerInBounds}from\"../utils\";var TouchEventManager=function(_EventManager){_inherits(TouchEventManager,_EventManager);var _super=_createSuper(TouchEventManager);function TouchEventManager(){_classCallCheck(this,TouchEventManager);return _super.apply(this,arguments);}_createClass(TouchEventManager,[{key:\"setListeners\",value:function setListeners(){var _this=this;this.view.addEventListener('touchstart',function(event){for(var i=0;i<event.changedTouches.length;++i){var adaptedEvent=_this.mapEvent(event,EventTypes.DOWN,i,TouchEventType.DOWN);if(!isPointerInBounds(_this.view,{x:adaptedEvent.x,y:adaptedEvent.y})||event.changedTouches[i].touchType==='stylus'){continue;}_this.markAsInBounds(adaptedEvent.pointerId);if(++_this.activePointersCounter>1){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_DOWN;_this.onPointerAdd(adaptedEvent);}else{_this.onPointerDown(adaptedEvent);}}});this.view.addEventListener('touchmove',function(event){for(var i=0;i<event.changedTouches.length;++i){var adaptedEvent=_this.mapEvent(event,EventTypes.MOVE,i,TouchEventType.MOVE);if(event.changedTouches[i].touchType==='stylus'){continue;}var inBounds=isPointerInBounds(_this.view,{x:adaptedEvent.x,y:adaptedEvent.y});var pointerIndex=_this.pointersInBounds.indexOf(adaptedEvent.pointerId);if(inBounds){if(pointerIndex<0){adaptedEvent.eventType=EventTypes.ENTER;_this.onPointerEnter(adaptedEvent);_this.markAsInBounds(adaptedEvent.pointerId);}else{_this.onPointerMove(adaptedEvent);}}else{if(pointerIndex>=0){adaptedEvent.eventType=EventTypes.OUT;_this.onPointerOut(adaptedEvent);_this.markAsOutOfBounds(adaptedEvent.pointerId);}else{_this.onPointerOutOfBounds(adaptedEvent);}}}});this.view.addEventListener('touchend',function(event){for(var i=0;i<event.changedTouches.length;++i){if(_this.activePointersCounter===0){break;}if(event.changedTouches[i].touchType==='stylus'){continue;}var adaptedEvent=_this.mapEvent(event,EventTypes.UP,i,TouchEventType.UP);_this.markAsOutOfBounds(adaptedEvent.pointerId);if(--_this.activePointersCounter>0){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_UP;_this.onPointerRemove(adaptedEvent);}else{_this.onPointerUp(adaptedEvent);}}});this.view.addEventListener('touchcancel',function(event){for(var i=0;i<event.changedTouches.length;++i){var adaptedEvent=_this.mapEvent(event,EventTypes.CANCEL,i,TouchEventType.CANCELLED);if(event.changedTouches[i].touchType==='stylus'){continue;}_this.onPointerCancel(adaptedEvent);_this.markAsOutOfBounds(adaptedEvent.pointerId);_this.activePointersCounter=0;}});}},{key:\"mapEvent\",value:function mapEvent(event,eventType,index,touchEventType){var rect=this.view.getBoundingClientRect();var clientX=event.changedTouches[index].clientX;var clientY=event.changedTouches[index].clientY;return{x:clientX,y:clientY,offsetX:clientX-rect.left,offsetY:clientY-rect.top,pointerId:event.changedTouches[index].identifier,eventType:eventType,pointerType:PointerType.TOUCH,buttons:MouseButtons.NONE,time:event.timeStamp,allTouches:event.touches,changedTouches:event.changedTouches,touchEventType:touchEventType};}}]);return TouchEventManager;}(EventManager);export{TouchEventManager as default};","map":{"version":3,"sources":["TouchEventManager.ts"],"names":["EventTypes","MouseButtons","PointerType","TouchEventType","EventManager","isPointerInBounds","TouchEventManager","setListeners","view","addEventListener","event","i","changedTouches","length","adaptedEvent","mapEvent","DOWN","x","y","touchType","markAsInBounds","pointerId","activePointersCounter","eventType","ADDITIONAL_POINTER_DOWN","onPointerAdd","onPointerDown","MOVE","inBounds","pointerIndex","pointersInBounds","indexOf","ENTER","onPointerEnter","onPointerMove","OUT","onPointerOut","markAsOutOfBounds","onPointerOutOfBounds","UP","ADDITIONAL_POINTER_UP","onPointerRemove","onPointerUp","CANCEL","CANCELLED","onPointerCancel","index","touchEventType","rect","getBoundingClientRect","clientX","clientY","offsetX","left","offsetY","top","identifier","pointerType","TOUCH","buttons","NONE","time","timeStamp","allTouches","touches"],"mappings":"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","sourcesContent":["import {\n  AdaptedEvent,\n  EventTypes,\n  MouseButtons,\n  PointerType,\n  TouchEventType,\n} from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\n\nexport default class TouchEventManager extends EventManager {\n  public setListeners(): void {\n    this.view.addEventListener('touchstart', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.DOWN,\n          i,\n          TouchEventType.DOWN\n        );\n\n        // Here we skip stylus, because in case of anything different than touch we want to handle it by using PointerEvents\n        // If we leave stylus to send touch events, handlers will receive every action twice\n        if (\n          !isPointerInBounds(this.view, {\n            x: adaptedEvent.x,\n            y: adaptedEvent.y,\n          }) ||\n          //@ts-ignore touchType field does exist\n          event.changedTouches[i].touchType === 'stylus'\n        ) {\n          continue;\n        }\n\n        this.markAsInBounds(adaptedEvent.pointerId);\n\n        if (++this.activePointersCounter > 1) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n          this.onPointerAdd(adaptedEvent);\n        } else {\n          this.onPointerDown(adaptedEvent);\n        }\n      }\n    });\n\n    this.view.addEventListener('touchmove', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.MOVE,\n          i,\n          TouchEventType.MOVE\n        );\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        const inBounds: boolean = isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y,\n        });\n\n        const pointerIndex: number = this.pointersInBounds.indexOf(\n          adaptedEvent.pointerId\n        );\n\n        if (inBounds) {\n          if (pointerIndex < 0) {\n            adaptedEvent.eventType = EventTypes.ENTER;\n            this.onPointerEnter(adaptedEvent);\n            this.markAsInBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerMove(adaptedEvent);\n          }\n        } else {\n          if (pointerIndex >= 0) {\n            adaptedEvent.eventType = EventTypes.OUT;\n            this.onPointerOut(adaptedEvent);\n            this.markAsOutOfBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerOutOfBounds(adaptedEvent);\n          }\n        }\n      }\n    });\n\n    this.view.addEventListener('touchend', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        // When we call reset on gesture handlers, it also resets their event managers\n        // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view\n        // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view\n        // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly\n        if (this.activePointersCounter === 0) {\n          break;\n        }\n\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.UP,\n          i,\n          TouchEventType.UP\n        );\n\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n\n        if (--this.activePointersCounter > 0) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n          this.onPointerRemove(adaptedEvent);\n        } else {\n          this.onPointerUp(adaptedEvent);\n        }\n      }\n    });\n\n    this.view.addEventListener('touchcancel', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.CANCEL,\n          i,\n          TouchEventType.CANCELLED\n        );\n\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        this.onPointerCancel(adaptedEvent);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n        this.activePointersCounter = 0;\n      }\n    });\n  }\n\n  protected mapEvent(\n    event: TouchEvent,\n    eventType: EventTypes,\n    index: number,\n    touchEventType: TouchEventType\n  ): AdaptedEvent {\n    const rect = this.view.getBoundingClientRect();\n    const clientX = event.changedTouches[index].clientX;\n    const clientY = event.changedTouches[index].clientY;\n\n    return {\n      x: clientX,\n      y: clientY,\n      offsetX: clientX - rect.left,\n      offsetY: clientY - rect.top,\n      pointerId: event.changedTouches[index].identifier,\n      eventType: eventType,\n      pointerType: PointerType.TOUCH,\n      buttons: MouseButtons.NONE,\n      time: event.timeStamp,\n      allTouches: event.touches,\n      changedTouches: event.changedTouches,\n      touchEventType: touchEventType,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}